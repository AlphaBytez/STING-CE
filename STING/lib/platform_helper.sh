#!/usr/bin/env bash
#
# Platform Helper - Detect platform and set Docker networking variables
#
# This script detects the platform (macOS, Linux, WSL2) and sets appropriate
# environment variables for Docker host connectivity across platforms.
#

set -euo pipefail

# ANSI color codes
readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[1;33m'
readonly BLUE='\033[0;34m'
readonly NC='\033[0m' # No Color

# Logging functions
log_info() {
    echo -e "${BLUE}[INFO]${NC} $*"
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $*"
}

log_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $*"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $*"
}

#
# Detect if running in WSL2
#
is_wsl2() {
    if [[ -f /proc/version ]] && grep -qi microsoft /proc/version; then
        # Check if WSL2 specifically (vs WSL1)
        if [[ -f /proc/sys/kernel/osrelease ]] && grep -qi microsoft /proc/sys/kernel/osrelease; then
            return 0
        fi
    fi
    return 1
}

#
# Detect platform type
# Returns: macos, linux, wsl2
#
detect_platform() {
    local platform=""

    case "$(uname -s)" in
        Darwin)
            platform="macos"
            ;;
        Linux)
            if is_wsl2; then
                platform="wsl2"
            else
                platform="linux"
            fi
            ;;
        CYGWIN*|MINGW*|MSYS*)
            platform="windows"
            ;;
        *)
            platform="unknown"
            ;;
    esac

    echo "$platform"
}

#
# Get Docker host gateway address based on platform
#
get_docker_host_gateway() {
    local platform="$1"
    local gateway=""

    case "$platform" in
        macos)
            # macOS Docker Desktop supports host.docker.internal natively
            gateway="host.docker.internal"
            ;;
        wsl2)
            # WSL2 with Docker Desktop also supports host.docker.internal
            # But we'll check if Docker Desktop is installed
            if command -v docker.exe &> /dev/null; then
                gateway="host.docker.internal"
            else
                # Native Docker in WSL2 - use bridge IP
                gateway="172.17.0.1"
            fi
            ;;
        linux)
            # Native Linux Docker - use bridge gateway IP
            # This will be added via extra_hosts in docker-compose
            gateway="172.17.0.1"
            ;;
        windows)
            # Windows Docker Desktop
            gateway="host.docker.internal"
            ;;
        *)
            log_warning "Unknown platform, defaulting to host.docker.internal"
            gateway="host.docker.internal"
            ;;
    esac

    echo "$gateway"
}

#
# Check if extra_hosts is needed in docker-compose.yml
# Returns: 0 if needed, 1 if not
#
needs_extra_hosts() {
    local platform="$1"

    case "$platform" in
        linux|wsl2)
            # Linux and WSL2 (without Docker Desktop) need extra_hosts
            if [[ "$platform" == "wsl2" ]] && command -v docker.exe &> /dev/null; then
                return 1  # Docker Desktop in WSL2, no extra_hosts needed
            fi
            return 0  # Need extra_hosts
            ;;
        *)
            return 1  # Don't need extra_hosts
            ;;
    esac
}

#
# Generate platform-specific environment variables
#
generate_platform_env() {
    local platform="$1"
    local gateway="$2"
    local output_file="${3:-}"

    cat <<EOF
# Platform-specific Docker networking configuration
# Generated by platform_helper.sh on $(date)
# Platform: $platform

# Docker host gateway address (for accessing host services from containers)
DOCKER_HOST_GATEWAY=$gateway

# Platform identifier
STING_PLATFORM=$platform

# Extra hosts needed (for docker-compose.yml)
EXTRA_HOSTS_NEEDED=$(needs_extra_hosts "$platform" && echo "true" || echo "false")
EOF

    if [[ -n "$output_file" ]]; then
        cat > "$output_file" <<EOF
# Platform-specific Docker networking configuration
# Generated by platform_helper.sh on $(date)
# Platform: $platform

DOCKER_HOST_GATEWAY=$gateway
STING_PLATFORM=$platform
EXTRA_HOSTS_NEEDED=$(needs_extra_hosts "$platform" && echo "true" || echo "false")
EOF
        log_success "Platform configuration written to $output_file"
    fi
}

#
# Patch docker-compose.yml to use platform-aware networking
#
patch_docker_compose() {
    local compose_file="$1"
    local platform="$2"

    if [[ ! -f "$compose_file" ]]; then
        log_error "Docker compose file not found: $compose_file"
        return 1
    fi

    # Create backup
    cp "$compose_file" "${compose_file}.backup-$(date +%s)"
    log_info "Created backup: ${compose_file}.backup-$(date +%s)"

    # For Linux/WSL2 (without Docker Desktop), we need to add extra_hosts
    if needs_extra_hosts "$platform"; then
        log_info "Adding extra_hosts configuration for $platform platform..."

        # Note: This is a simple implementation. For production, consider using yq or Python
        # to properly parse and modify YAML files.
        log_warning "Manual step required: Add the following to services that need host access:"
        echo ""
        echo "    extra_hosts:"
        echo "      - \"host.docker.internal:host-gateway\""
        echo ""
        log_info "Services that typically need this: nectar-worker, external-ai, chatbot"
    else
        log_success "Platform $platform supports host.docker.internal natively - no patching needed"
    fi
}

#
# Update environment files to use platform-aware gateway
#
update_env_files() {
    local env_dir="$1"
    local gateway="$2"

    if [[ ! -d "$env_dir" ]]; then
        log_warning "Environment directory not found: $env_dir"
        return 1
    fi

    log_info "Updating environment files to use gateway: $gateway"

    # List of env files that might use host.docker.internal
    local env_files=(
        "nectar-worker.env"
        "external-ai.env"
        "chatbot.env"
        "llm-gateway.env"
    )

    local updated_count=0

    for env_file in "${env_files[@]}"; do
        local full_path="$env_dir/$env_file"

        if [[ -f "$full_path" ]]; then
            # Check if file contains host.docker.internal
            if grep -q "host.docker.internal" "$full_path"; then
                # Create backup
                cp "$full_path" "${full_path}.backup-$(date +%s)"

                # Replace host.docker.internal with platform-specific gateway
                sed -i.tmp "s|host\.docker\.internal|${gateway}|g" "$full_path"
                rm -f "${full_path}.tmp"

                log_success "Updated $env_file"
                ((updated_count++))
            fi
        fi
    done

    if [[ $updated_count -eq 0 ]]; then
        log_info "No environment files needed updating"
    else
        log_success "Updated $updated_count environment files"
    fi
}

#
# Main function - detect platform and generate configuration
#
main() {
    local command="${1:-detect}"

    case "$command" in
        detect)
            local platform
            platform=$(detect_platform)
            echo "$platform"
            ;;

        gateway)
            local platform
            platform=$(detect_platform)
            get_docker_host_gateway "$platform"
            ;;

        env)
            local platform
            platform=$(detect_platform)
            local gateway
            gateway=$(get_docker_host_gateway "$platform")
            local output_file="${2:-}"

            generate_platform_env "$platform" "$gateway" "$output_file"
            ;;

        patch-compose)
            local compose_file="${2:-docker-compose.yml}"
            local platform
            platform=$(detect_platform)

            patch_docker_compose "$compose_file" "$platform"
            ;;

        update-env)
            local env_dir="${2:-.}"
            local platform
            platform=$(detect_platform)
            local gateway
            gateway=$(get_docker_host_gateway "$platform")

            update_env_files "$env_dir" "$gateway"
            ;;

        info)
            local platform
            platform=$(detect_platform)
            local gateway
            gateway=$(get_docker_host_gateway "$platform")
            local needs_hosts
            needs_extra_hosts "$platform" && needs_hosts="yes" || needs_hosts="no"

            echo ""
            log_info "Platform Detection Results"
            echo "─────────────────────────────────────────"
            echo "  Platform:              $platform"
            echo "  Docker Host Gateway:   $gateway"
            echo "  Needs extra_hosts:     $needs_hosts"
            echo "─────────────────────────────────────────"
            echo ""
            ;;

        help|--help|-h)
            cat <<EOF
Usage: $0 <command> [arguments]

Platform Helper - Detect platform and configure Docker networking

Commands:
  detect              Detect platform (macos, linux, wsl2, windows)
  gateway             Get Docker host gateway address for current platform
  env [output_file]   Generate platform environment variables
  patch-compose [file] Patch docker-compose.yml for platform compatibility
  update-env [dir]    Update environment files with platform-specific gateway
  info                Display platform detection information
  help                Show this help message

Examples:
  # Detect current platform
  $0 detect

  # Get gateway address
  $0 gateway

  # Generate platform env file
  $0 env ~/.sting-ce/.platform.env

  # Update environment files
  $0 update-env ~/.sting-ce/env

  # Show platform info
  $0 info

EOF
            ;;

        *)
            log_error "Unknown command: $command"
            echo "Run '$0 help' for usage information"
            exit 1
            ;;
    esac
}

# Run main function if script is executed (not sourced)
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi
