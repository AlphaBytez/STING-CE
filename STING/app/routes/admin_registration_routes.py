#!/usr/bin/env python3
"""
Admin Registration Routes - Proper admin onboarding flow
Handles upgrading regular registrations to admin role with proper security
"""

from flask import Blueprint, request, jsonify, session
from flask_cors import cross_origin
import logging
import requests
import os
from datetime import datetime, timedelta
from app.utils.decorators import require_auth
from app.utils.kratos_session import whoami
from app.utils.response_helpers import success_response, error_response

logger = logging.getLogger(__name__)
admin_registration_bp = Blueprint('admin_registration', __name__)

# Admin registration tokens (in production, use Redis with expiration)
admin_registration_tokens = {}

def verify_admin_registration_secret(provided_secret):
    """Verify the admin registration secret"""
    # In production, this should be stored securely in Vault
    admin_secret = os.getenv('ADMIN_REGISTRATION_SECRET', 'admin-setup-secret-change-me')
    return provided_secret == admin_secret

@admin_registration_bp.route('/api/admin-registration/generate-token', methods=['POST'])
@require_auth
def generate_admin_registration_token():
    """Generate an admin registration token (existing admin only)"""
    try:
        # Check if user is admin
        session_info = whoami(request)
        if not session_info:
            return error_response("Not authenticated", 401)
        
        traits = session_info.get('identity', {}).get('traits', {})
        user_role = traits.get('role', 'user')
        user_email = traits.get('email', 'unknown')
        
        if user_role != 'admin':
            logger.warning(f"Non-admin user {user_email} attempted to generate admin registration token")
            return error_response("Admin access required", 403)
        
        # Generate registration token
        import secrets
        token = secrets.token_urlsafe(32)
        
        # Store token with expiration (24 hours)
        admin_registration_tokens[token] = {
            'created_by': user_email,
            'created_at': datetime.utcnow(),
            'expires_at': datetime.utcnow() + timedelta(hours=24),
            'used': False
        }
        
        logger.info(f"Admin registration token generated by {user_email}")
        
        return success_response({
            'token': token,
            'expires_in': 86400,  # 24 hours in seconds
            'message': 'Admin registration token generated. Share this with the new admin for registration.'
        })
        
    except Exception as e:
        logger.error(f"Error generating admin registration token: {str(e)}")
        return error_response("Failed to generate token", 500)

@admin_registration_bp.route('/api/admin-registration/verify-token', methods=['POST'])
@cross_origin(supports_credentials=True)
def verify_admin_registration_token():
    """Verify an admin registration token (public endpoint for registration)"""
    try:
        data = request.get_json()
        token = data.get('token')
        
        if not token:
            return error_response("Registration token required", 400)
        
        # Check token validity
        token_data = admin_registration_tokens.get(token)
        if not token_data:
            return error_response("Invalid registration token", 401)
        
        if token_data['used']:
            return error_response("Registration token already used", 401)
        
        if datetime.utcnow() > token_data['expires_at']:
            return error_response("Registration token expired", 401)
        
        return success_response({
            'valid': True,
            'created_by': token_data['created_by'],
            'expires_at': token_data['expires_at'].isoformat()
        })
        
    except Exception as e:
        logger.error(f"Error verifying admin registration token: {str(e)}")
        return error_response("Failed to verify token", 500)

@admin_registration_bp.route('/api/admin-registration/upgrade-to-admin', methods=['POST'])
@cross_origin(supports_credentials=True)
def upgrade_to_admin():
    """Upgrade a user to admin role using registration token"""
    try:
        data = request.get_json()
        token = data.get('token')
        email = data.get('email')
        
        if not token or not email:
            return error_response("Registration token and email required", 400)
        
        # Verify token
        token_data = admin_registration_tokens.get(token)
        if not token_data or token_data['used'] or datetime.utcnow() > token_data['expires_at']:
            return error_response("Invalid or expired registration token", 401)
        
        # Get user session to verify they completed registration
        session_info = whoami(request)
        if not session_info:
            return error_response("User must complete registration first", 401)
        
        session_email = session_info.get('identity', {}).get('traits', {}).get('email')
        if session_email != email:
            return error_response("Email mismatch - please login with the registered account", 403)
        
        # Update user role to admin via Kratos Admin API
        identity_id = session_info.get('identity', {}).get('id')
        if not identity_id:
            return error_response("Invalid user session", 400)
        
        KRATOS_ADMIN_URL = os.getenv('KRATOS_ADMIN_URL', 'https://kratos:4434')
        
        # Get current identity
        get_response = requests.get(
            f"{KRATOS_ADMIN_URL}/admin/identities/{identity_id}",
            verify=False,
            headers={"Accept": "application/json"},
            timeout=10
        )
        
        if get_response.status_code != 200:
            logger.error(f"Failed to fetch identity {identity_id}: {get_response.status_code}")
            return error_response("Failed to fetch user data", 500)
        
        identity = get_response.json()
        
        # Update traits to include admin role
        traits = identity.get('traits', {})
        traits['role'] = 'admin'
        
        update_data = {
            "schema_id": identity.get('schema_id', 'default'),
            "traits": traits
        }
        
        # Update identity
        update_response = requests.put(
            f"{KRATOS_ADMIN_URL}/admin/identities/{identity_id}",
            json=update_data,
            verify=False,
            headers={"Content-Type": "application/json"},
            timeout=10
        )
        
        if update_response.status_code != 200:
            logger.error(f"Failed to update identity {identity_id}: {update_response.status_code} - {update_response.text}")
            return error_response("Failed to upgrade to admin role", 500)
        
        # Mark token as used
        token_data['used'] = True
        token_data['upgraded_user'] = email
        token_data['upgraded_at'] = datetime.utcnow()
        
        logger.info(f"Successfully upgraded {email} to admin role using token from {token_data['created_by']}")
        
        return success_response({
            'message': 'Successfully upgraded to admin role',
            'email': email,
            'role': 'admin'
        })
        
    except Exception as e:
        logger.error(f"Error upgrading to admin: {str(e)}")
        return error_response("Failed to upgrade to admin", 500)

@admin_registration_bp.route('/api/admin-registration/emergency-upgrade', methods=['POST'])
@cross_origin(supports_credentials=True)
def emergency_admin_upgrade():
    """Emergency admin upgrade using master secret (for initial setup)"""
    try:
        data = request.get_json()
        secret = data.get('secret')
        email = data.get('email')
        
        if not secret or not email:
            return error_response("Secret and email required", 400)
        
        # Verify admin registration secret
        if not verify_admin_registration_secret(secret):
            logger.warning(f"Invalid admin registration secret attempt for {email}")
            return error_response("Invalid admin registration secret", 401)
        
        # Get user session
        session_info = whoami(request)
        if not session_info:
            return error_response("User must complete registration first", 401)
        
        session_email = session_info.get('identity', {}).get('traits', {}).get('email')
        if session_email != email:
            return error_response("Email mismatch", 403)
        
        # Update role (same logic as token upgrade)
        identity_id = session_info.get('identity', {}).get('id')
        KRATOS_ADMIN_URL = os.getenv('KRATOS_ADMIN_URL', 'https://kratos:4434')
        
        get_response = requests.get(
            f"{KRATOS_ADMIN_URL}/admin/identities/{identity_id}",
            verify=False,
            headers={"Accept": "application/json"},
            timeout=10
        )
        
        if get_response.status_code != 200:
            return error_response("Failed to fetch user data", 500)
        
        identity = get_response.json()
        traits = identity.get('traits', {})
        traits['role'] = 'admin'
        
        update_data = {
            "schema_id": identity.get('schema_id', 'default'),
            "traits": traits
        }
        
        update_response = requests.put(
            f"{KRATOS_ADMIN_URL}/admin/identities/{identity_id}",
            json=update_data,
            verify=False,
            headers={"Content-Type": "application/json"},
            timeout=10
        )
        
        if update_response.status_code != 200:
            return error_response("Failed to upgrade to admin role", 500)
        
        logger.info(f"Emergency admin upgrade completed for {email}")
        
        return success_response({
            'message': 'Emergency admin upgrade completed',
            'email': email,
            'role': 'admin'
        })
        
    except Exception as e:
        logger.error(f"Error in emergency admin upgrade: {str(e)}")
        return error_response("Emergency upgrade failed", 500)

@admin_registration_bp.route('/api/admin-registration/status', methods=['GET'])
@cross_origin(supports_credentials=True)
def get_admin_registration_status():
    """Get admin registration system status"""
    try:
        # Clean up expired tokens
        current_time = datetime.utcnow()
        expired_tokens = [
            token for token, data in admin_registration_tokens.items()
            if current_time > data['expires_at']
        ]
        for token in expired_tokens:
            del admin_registration_tokens[token]
        
        # Count active tokens
        active_tokens = len([
            t for t, d in admin_registration_tokens.items()
            if not d['used'] and current_time <= d['expires_at']
        ])
        
        return success_response({
            'active_tokens': active_tokens,
            'emergency_upgrade_available': bool(os.getenv('ADMIN_REGISTRATION_SECRET')),
            'registration_enabled': True
        })
        
    except Exception as e:
        logger.error(f"Error getting admin registration status: {str(e)}")
        return error_response("Failed to get status", 500)