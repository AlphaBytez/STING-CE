"""
Admin Routes for STING-CE
Handles admin-specific functionality like demo data generation.
"""

import os
import logging
import tempfile
import json
import requests
from flask import Blueprint, request, jsonify, g
from datetime import datetime, timedelta
from typing import Dict, Any

from app.utils.decorators import require_auth, require_auth_or_api_key
from app.utils.flexible_auth import require_auth_flexible, get_current_auth_user
from app.database import get_db_session
from app.models.user_models import User
from app.models.report_models import Report, ReportTemplate, ReportStatus
from app.services.report_service import get_report_service
from app.services.file_service import get_file_service
from app.services.honey_jar_service import get_honey_jar_service
from app.utils.init_report_templates import create_default_templates
from app.services.demo_data_generator import MedicalDemoGenerator, LegalDemoGenerator, FinancialDemoGenerator, generate_demo_dataset

logger = logging.getLogger(__name__)

# Create blueprint
admin_bp = Blueprint('admin', __name__, url_prefix='/api/admin')

def generate_demo_report_content(category: str, scenario: str) -> str:
    """Generate realistic demo report content based on category and scenario"""

    if category == "healthcare":
        return f"""
HEALTHCARE COMPLIANCE REPORT
Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
Scenario: {scenario.title()}

EXECUTIVE SUMMARY:
This report provides a comprehensive analysis of healthcare data compliance across
the organization's medical records and patient information systems.

HIPAA COMPLIANCE STATUS:
✓ Patient Records: 847 files analyzed
✓ PII Detection: 1,234 instances of protected health information identified
✓ Access Controls: Properly configured for 98.5% of medical documents
⚠ Recommendations: 12 files require attention for full compliance

FINDINGS:
• Medical Record Numbers (MRN): Found in 847 documents
• Social Security Numbers: 234 instances detected and flagged
• Patient Names: 1,847 occurrences across intake forms and reports
• Date of Birth information: 656 instances in patient records
• Insurance ID Numbers: 445 policy numbers identified

PII SCRUBBING EFFECTIVENESS:
• Successfully anonymized: 94.2% of detected PII
• Partial anonymization: 4.8% (requires manual review)
• False positives: 1.0% (acceptable threshold)

RECOMMENDATIONS:
1. Implement enhanced MRN masking protocols
2. Review access permissions for 12 flagged documents
3. Update staff training on PHI handling procedures
4. Schedule quarterly compliance audits

Report generated by STING PII Compliance System
"""

    elif category == "security":
        return f"""
SECURITY AUDIT REPORT
Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
Scenario: {scenario.title()}

OVERVIEW:
Comprehensive security assessment of document repositories and data handling procedures.

PII DETECTION SUMMARY:
Total Documents Scanned: 2,347
PII Instances Detected: 8,642
High-Risk Classifications: 156
Medium-Risk Classifications: 523
Low-Risk Classifications: 1,668

DETECTED PII TYPES:
• Social Security Numbers: 1,234 instances
• Credit Card Numbers: 456 instances
• Email Addresses: 2,847 instances
• Phone Numbers: 1,923 instances
• Physical Addresses: 1,456 instances
• Driver's License Numbers: 287 instances
• Medical Record Numbers: 439 instances

SECURITY POSTURE:
✓ Encryption: AES-256 applied to all sensitive documents
✓ Access Controls: Role-based permissions implemented
✓ Audit Logging: Complete activity trail maintained
⚠ Network Security: 3 recommendations for improvement

COMPLIANCE FRAMEWORKS:
• GDPR: 87% compliant (13% requires attention)
• CCPA: 92% compliant (8% minor issues)
• HIPAA: 94% compliant (6% documentation updates needed)
• SOX: 89% compliant (11% process improvements)

RISK ASSESSMENT:
High Risk: 12 documents with unencrypted SSNs
Medium Risk: 45 files with partial PII exposure
Low Risk: 234 documents with minor compliance gaps

REMEDIATION PLAN:
1. Immediate: Encrypt 12 high-risk documents
2. Short-term: Update access controls for 45 medium-risk files
3. Long-term: Implement automated PII scanning for new uploads
"""

    elif category == "legal":
        return f"""
LEGAL DOCUMENT ANALYSIS REPORT
Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
Scenario: {scenario.title()}

DOCUMENT REVIEW SUMMARY:
Total Legal Documents: 156
Contracts Analyzed: 89
Case Files Reviewed: 34
Compliance Documents: 33

ATTORNEY-CLIENT PRIVILEGE PROTECTION:
✓ Privileged Communications: 67 documents properly classified
✓ Work Product Doctrine: 23 documents identified and protected
✓ Confidentiality Markers: 145 documents properly labeled
⚠ Review Required: 11 documents need privilege verification

PII IN LEGAL DOCUMENTS:
• Client SSNs: 45 instances detected
• Attorney Bar Numbers: 12 professional IDs found
• Case Numbers: 156 court identifiers catalogued
• Financial Information: 78 instances of monetary data
• Personal Addresses: 234 client/witness addresses

COMPLIANCE STATUS:
• Professional Ethics Rules: 94% compliant
• Discovery Obligations: 87% properly handled
• Client Confidentiality: 98% appropriately protected
• Document Retention: 92% following firm policies

RISK ANALYSIS:
Low Risk: Most documents properly handled
Medium Risk: 11 files require privilege review
High Risk: 0 critical violations detected

RECOMMENDATIONS:
1. Review privilege status for 11 flagged documents
2. Implement automated privilege detection
3. Update document classification procedures
4. Train staff on new confidentiality protocols
"""

    elif category == "financial":
        return f"""
FINANCIAL DATA ASSESSMENT REPORT
Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
Scenario: {scenario.title()}

PCI-DSS COMPLIANCE REVIEW:
Total Financial Documents: 234
Credit Card Data: 89 instances detected
Bank Account Numbers: 45 instances found
Tax ID Numbers: 67 instances identified

CARDHOLDER DATA ENVIRONMENT:
✓ Primary Account Numbers: Properly masked in 94% of instances
✓ Sensitive Authentication Data: Prohibited data not stored
✓ Cardholder Data: Encrypted at rest and in transit
⚠ Tokenization: 6% of systems require token implementation

VULNERABILITY ASSESSMENT:
• Network Segmentation: Properly configured
• Access Controls: 98% of systems compliant
• Encryption Standards: AES-256 implemented
• Monitoring Systems: Real-time fraud detection active

FINANCIAL PII DETECTED:
• Credit Card Numbers: 89 full PANs identified
• Bank Routing Numbers: 45 ACH details found
• Account Numbers: 67 financial account IDs
• Tax Identification: 34 EIN/SSN combinations
• Payment Processor IDs: 23 merchant numbers

COMPLIANCE SCORES:
• PCI-DSS Level 1: 92% compliant (8% remediation needed)
• SOX Financial Controls: 87% compliant
• FFIEC Guidelines: 94% compliant
• State Privacy Laws: 89% compliant

ACTION ITEMS:
1. Implement tokenization for 6% of legacy systems
2. Update encryption protocols for 8% of data stores
3. Enhance monitoring for suspicious transaction patterns
4. Quarterly PCI compliance validation
"""

    elif category == "pii":
        return f"""
PII SCRUBBING VALIDATION REPORT
Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
Scenario: {scenario.title()}

BEFORE/AFTER ANALYSIS:
Original Documents: 1,247
PII Instances (Before): 15,647
PII Instances (After): 234
Scrubbing Effectiveness: 98.5%

PII TYPE BREAKDOWN:
Social Security Numbers:
  • Before: 2,347 instances
  • After: 12 instances (0.5% retention for format validation)
  • Effectiveness: 99.5%

Email Addresses:
  • Before: 4,567 instances
  • After: 89 instances (domain preservation for testing)
  • Effectiveness: 98.1%

Phone Numbers:
  • Before: 3,234 instances
  • After: 45 instances (area code preservation)
  • Effectiveness: 98.6%

Credit Card Numbers:
  • Before: 1,456 instances
  • After: 0 instances (complete removal)
  • Effectiveness: 100%

Medical Record Numbers:
  • Before: 2,567 instances
  • After: 67 instances (format preservation for testing)
  • Effectiveness: 97.4%

QUALITY METRICS:
• False Positives: 1.2% (acceptable threshold <2%)
• False Negatives: 0.3% (excellent detection rate)
• Format Preservation: 94% (maintains document usability)
• Readability Score: 8.7/10 (post-scrubbing)

VALIDATION RESULTS:
✓ Automated Testing: 10,000 test cases passed
✓ Manual Review: 100 documents spot-checked
✓ Compliance Check: GDPR/HIPAA requirements met
✓ Performance: <2 seconds average processing time

RECOMMENDATIONS:
1. Fine-tune MRN detection patterns (2.6% improvement possible)
2. Enhance email domain preservation logic
3. Implement real-time scrubbing quality scoring
4. Expand test dataset for edge case validation
"""

    elif category == "detection":
        return f"""
DETECTION PATTERN ANALYSIS REPORT
Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
Scenario: {scenario.title()}

PATTERN EFFECTIVENESS ANALYSIS:
Total Patterns Evaluated: 47
Active Detection Rules: 42
Retired Patterns: 5
New Patterns Added: 8

DETECTION ACCURACY BY TYPE:
SSN Pattern (XXX-XX-XXXX):
  • Precision: 99.2%
  • Recall: 98.7%
  • F1-Score: 98.95%

Credit Card Pattern (XXXX-XXXX-XXXX-XXXX):
  • Precision: 97.8%
  • Recall: 99.1%
  • F1-Score: 98.44%

Email Pattern (user@domain.tld):
  • Precision: 96.5%
  • Recall: 98.9%
  • F1-Score: 97.69%

Phone Pattern ((XXX) XXX-XXXX):
  • Precision: 94.2%
  • Recall: 96.8%
  • F1-Score: 95.48%

Medical Record Numbers:
  • Precision: 89.7%
  • Recall: 92.3%
  • F1-Score: 91.98%

PATTERN PERFORMANCE METRICS:
• Average Processing Time: 1.3 seconds per document
• Memory Usage: 45MB average per analysis
• CPU Utilization: 23% during peak processing
• Throughput: 847 documents/hour

FALSE POSITIVE ANALYSIS:
• Date Formats mistaken for SSNs: 0.8%
• Product Codes mistaken for Credit Cards: 1.2%
• URLs mistaken for Email Addresses: 0.3%
• Reference Numbers mistaken for Phone Numbers: 0.7%

PATTERN OPTIMIZATION RECOMMENDATIONS:
1. Refine MRN patterns to reduce false positives by 2.3%
2. Add context analysis for SSN detection (birth year validation)
3. Implement Luhn algorithm validation for credit card patterns
4. Enhance phone number international format support
5. Add machine learning enhancement for pattern confidence scoring
"""

    else:  # general or fallback
        return f"""
DOCUMENT PROCESSING REPORT
Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
Scenario: {scenario.title()}

PROCESSING SUMMARY:
Total Documents Processed: 1,247
Successfully Analyzed: 1,234 (99.0%)
Processing Errors: 13 (1.0%)
Average Processing Time: 2.3 seconds per document

FILE TYPE BREAKDOWN:
• PDF Documents: 567 files (45.5%)
• Microsoft Word: 234 files (18.8%)
• Text Files: 189 files (15.2%)
• Excel Spreadsheets: 123 files (9.9%)
• PowerPoint: 89 files (7.1%)
• Other Formats: 45 files (3.6%)

CONTENT ANALYSIS:
• Text Extraction Success: 98.7%
• OCR Processing: 145 scanned documents
• Language Detection: 99.2% accuracy
• Character Encoding: UTF-8 standardized

PII SUMMARY:
Total PII Instances: 8,642
Most Common: Email addresses (32.9%)
Least Common: Passport numbers (0.2%)
High Confidence: 94.7% of detections
Manual Review Required: 5.3%

QUALITY METRICS:
• Document Completeness: 99.0%
• Text Clarity Score: 8.4/10
• Processing Accuracy: 98.7%
• System Uptime: 99.9%

SYSTEM PERFORMANCE:
• Peak Throughput: 1,200 docs/hour
• Average Memory Usage: 2.3GB
• Storage Efficiency: 87% compression ratio
• Error Recovery: 100% of failures recovered

RECOMMENDATIONS:
1. Optimize OCR processing for scanned documents
2. Implement batch processing for large document sets
3. Add support for additional file formats
4. Enhance error reporting and recovery mechanisms
"""

def get_user_role() -> str:
    """Get current user role from database"""
    # Check for API key authentication first
    if hasattr(g, 'api_key') and g.api_key:
        # For API keys, check scopes to determine role
        if 'admin' in g.api_key.scopes:
            return 'admin'
        else:
            return 'user'

    # Fall back to session authentication
    auth_user = get_current_auth_user()
    if not auth_user:
        return 'user'

    user_id = auth_user['id']

    with get_db_session() as session:
        user = session.query(User).filter(User.kratos_id == user_id).first()
        if user:
            if user.is_super_admin:
                return 'super_admin'
            elif user.is_admin:
                return 'admin'
        return 'user'

@admin_bp.route('/generate-demo-data', methods=['POST'])
@require_auth_or_api_key(['admin'])
def generate_demo_data():
    """Generate demo data for testing and demonstrations"""
    step = None  # Initialize step variable for exception handling
    try:
        # Check admin permissions
        user_role = get_user_role()
        if user_role not in ['admin', 'super_admin']:
            return jsonify({'error': 'Admin access required'}), 403

        data = request.get_json()
        scenario = data.get('scenario', 'basic')
        step = data.get('step', 1)
        total_steps = data.get('totalSteps', 5)
        
        logger.info(f"🔍 DEMO API: Generating demo data - scenario: {scenario}, step: {step}/{total_steps}")
        logger.info(f"🔍 DEMO API: Step value type: {type(step)}, value: {repr(step)}")
        
        # Initialize response
        response_data = {
            'success': True,
            'scenario': scenario,
            'step': step,
            'totalSteps': total_steps,
            'generated': True,
            'reports': 0,
            'honeyJars': 0,
            'documents': 0,
            'users': 0
        }
        
        # Step-based generation
        if step == 1:
            # Step 1: Initialize report templates
            with get_db_session() as session:
                templates_created = create_default_templates(session)
                response_data['message'] = f'Created {templates_created} report templates'
                logger.info(f"Created {templates_created} report templates")
        
        elif step == 2:
            # Step 2: Generate demo documents with realistic content
            if hasattr(g, 'api_key') and g.api_key:
                user_id = g.api_key.user_id
            else:
                auth_user = get_current_auth_user()
                user_id = auth_user['id']

            # Generate realistic demo documents based on scenario
            documents_created = 0
            demo_docs = []

            if scenario in ['basic', 'comprehensive', 'healthcare']:
                # Generate medical demo documents
                medical_gen = MedicalDemoGenerator()
                demo_docs = [
                    ("Patient_Intake_Form.txt", medical_gen.generate_patient_intake_form()),
                    ("Lab_Results_Report.txt", medical_gen.generate_lab_results()),
                    ("Prescription_Form.txt", medical_gen.generate_prescription()),
                ]
                documents_created += len(demo_docs)

            if scenario in ['comprehensive', 'security-focused']:
                # Add legal and financial demos
                legal_gen = LegalDemoGenerator()
                financial_gen = FinancialDemoGenerator()

                demo_docs.extend([
                    ("Legal_Case_File.txt", legal_gen.generate_case_file()),
                    ("Service_Contract.txt", legal_gen.generate_contract()),
                    ("Loan_Application.txt", financial_gen.generate_loan_application()),
                ])
                documents_created += 3

            if scenario == 'pii-scrubbing':
                # Generate diverse PII patterns for testing
                demo_dataset = generate_demo_dataset()
                for category, documents in demo_dataset.items():
                    for i, doc_content in enumerate(documents, 1):
                        demo_docs.append((f"{category}_sample_{i}.txt", doc_content))
                        documents_created += 1

            # Store demo documents for upload to honey jars in next step
            demo_files_dir = tempfile.mkdtemp(prefix='sting_demo_')
            demo_file_paths = []

            for filename, content in demo_docs:
                filepath = os.path.join(demo_files_dir, filename)
                with open(filepath, 'w', encoding='utf-8') as f:
                    f.write(content)
                demo_file_paths.append(filepath)

            # Store file paths in session/cache for next step
            # In a real implementation, this would use Redis or database storage
            import json
            with open(os.path.join(demo_files_dir, 'file_manifest.json'), 'w') as f:
                json.dump({
                    'files': demo_file_paths,
                    'scenario': scenario,
                    'user_id': user_id,
                    'created_at': datetime.utcnow().isoformat()
                }, f)

            logger.info(f"Generated {documents_created} demo documents in {demo_files_dir}")

            response_data['documents'] = documents_created
            response_data['demo_files_dir'] = demo_files_dir
            response_data['demo_file_paths'] = demo_file_paths
            response_data['message'] = f'Generated {documents_created} realistic demo documents ready for honey jar upload'

        elif step == 3:
            # Step 3: Create ACTUAL honey jars using the working service
            honey_jar_service = get_honey_jar_service()

            # Create scenario-specific honey jars using proven working code
            created_jars = honey_jar_service.create_demo_honey_jars(scenario)

            response_data['honeyJars'] = len(created_jars)
            response_data['honey_jar_names'] = [jar['name'] for jar in created_jars]
            response_data['honey_jar_ids'] = [jar['id'] for jar in created_jars]
            response_data['created_jars'] = created_jars  # Store for next step
            response_data['message'] = f'Created {len(created_jars)} real honey jars via knowledge service API'
            
        elif step == 4:
            # Step 4: Upload demo documents to honey jars (real data flow)
            logger.info(f"🚨 STEP 4 ENTRY: Step 4 is executing for scenario: {scenario}")
            logger.info(f"🔍 STEP 4 DEBUG: Starting document upload orchestration for scenario: {scenario}")
            honey_jar_service = get_honey_jar_service()

            # Initialize demo_document_sets as empty dict to avoid UnboundLocalError
            demo_document_sets = {}

            # Generate healthcare demo documents with PII
            logger.info(f"🔍 STEP 4 CONDITION: Checking scenario '{scenario}' in ['basic', 'comprehensive', 'healthcare']")
            scenario_match = scenario in ['basic', 'comprehensive', 'healthcare']
            logger.info(f"🔍 STEP 4 CONDITION: Result = {scenario_match}")

            if scenario_match:
                logger.info(f"✅ STEP 4: Scenario condition passed, initializing demo generators...")
                try:
                    medical_gen = MedicalDemoGenerator()
                    logger.info(f"✅ STEP 4: MedicalDemoGenerator created")
                    legal_gen = LegalDemoGenerator()
                    logger.info(f"✅ STEP 4: LegalDemoGenerator created")
                    financial_gen = FinancialDemoGenerator()
                    logger.info(f"✅ STEP 4: FinancialDemoGenerator created")
                except Exception as gen_error:
                    logger.error(f"❌ STEP 4: Demo generator initialization failed: {gen_error}")
                    raise

                # Create realistic demo documents
                demo_document_sets = {
                    'patient_records': [
                        ("Patient_Intake_Form_001.txt", medical_gen.generate_patient_intake_form()),
                        ("Patient_Intake_Form_002.txt", medical_gen.generate_patient_intake_form()),
                        ("Patient_Intake_Form_003.txt", medical_gen.generate_patient_intake_form()),
                    ],
                    'lab_results': [
                        ("Lab_Results_Report_001.txt", medical_gen.generate_lab_results()),
                        ("Lab_Results_Report_002.txt", medical_gen.generate_lab_results()),
                    ],
                    'prescriptions': [
                        ("Prescription_Form_001.txt", medical_gen.generate_prescription()),
                        ("Prescription_Form_002.txt", medical_gen.generate_prescription()),
                    ],
                    'compliance': [
                        ("Legal_Case_File.txt", legal_gen.generate_case_file()),
                        ("Financial_Report.txt", financial_gen.generate_loan_application()),
                    ]
                }
            elif scenario == 'nectar-bot':
                # For nectar-bot scenario, we don't need to upload documents
                # The bot data was created in step 3
                logger.info(f"ℹ️ STEP 4: Nectar-bot scenario - skipping document upload (bots created in step 3)")
                response_data['message'] = 'Nectar bot demo data ready (no document upload needed for bots)'
                response_data['documents'] = 0
                # Skip to step 5
                return jsonify(response_data), 200

            # Get demo honey jars created in Step 3 (look for demo jars)
            import requests
            knowledge_service_url = os.environ.get('KNOWLEDGE_SERVICE_URL', 'http://knowledge:8090')

            try:
                # Get list of demo honey jars
                jars_response = requests.get(
                    f"{knowledge_service_url}/honey-jars",
                    headers={'X-API-Key': 'sk_XG0Ya4nWFCHn-FLSiPclK58zida1Xsj4w7f-XBQV8I0'},
                    timeout=10
                )

                if jars_response.status_code == 200:
                    all_jars = jars_response.json()
                    logger.info(f"🔍 STEP 4 DEBUG: Total jars available: {len(all_jars)}")

                    # Debug jar filtering
                    demo_jars = []
                    for jar in all_jars:
                        has_demo = 'Demo' in jar['name']
                        has_healthcare = 'healthcare' in jar.get('tags', [])
                        logger.info(f"🔍 STEP 4 JAR: '{jar['name']}' | Demo={has_demo} | Healthcare={has_healthcare} | Tags={jar.get('tags', [])}")

                        if has_demo and has_healthcare:
                            demo_jars.append(jar)

                    logger.info(f"🔍 STEP 4 DEBUG: Found {len(demo_jars)} demo honey jars matching criteria (Demo in name + healthcare in tags)")

                    documents_uploaded = 0
                    total_size = 0

                    # Upload documents to appropriate honey jars
                    for jar in demo_jars:
                        jar_name = jar['name'].lower()
                        jar_id = jar['id']

                        # Determine which documents to upload based on jar type
                        if 'patient' in jar_name:
                            docs_to_upload = demo_document_sets.get('patient_records', [])
                        elif 'lab' in jar_name:
                            docs_to_upload = demo_document_sets.get('lab_results', [])
                        elif 'prescription' in jar_name:
                            docs_to_upload = demo_document_sets.get('prescriptions', [])
                        elif 'compliance' in jar_name or 'hipaa' in jar_name:
                            docs_to_upload = demo_document_sets.get('compliance', [])
                        else:
                            docs_to_upload = demo_document_sets.get('patient_records', [])[:1]  # Default

                        # Upload documents to this honey jar
                        for filename, content in docs_to_upload:
                            try:
                                success = honey_jar_service.upload_text_content(
                                    jar_id=jar_id,
                                    filename=filename,
                                    content=content,
                                    tags=['healthcare', 'demo', 'pii', scenario]
                                )

                                if success:
                                    documents_uploaded += 1
                                    total_size += len(content.encode('utf-8'))
                                    logger.info(f"Uploaded {filename} to {jar['name']}")
                                else:
                                    logger.warning(f"Failed to upload {filename} to {jar['name']}")

                            except Exception as upload_error:
                                logger.error(f"Error uploading {filename} to {jar['name']}: {upload_error}")

                    response_data['documents'] = documents_uploaded
                    response_data['total_size'] = total_size
                    response_data['message'] = f'Uploaded {documents_uploaded} healthcare documents with PII to {len(demo_jars)} honey jars'

                else:
                    logger.warning(f"Failed to get honey jars list: {jars_response.status_code}")
                    response_data['documents'] = 0
                    response_data['message'] = 'Failed to get honey jars for document upload'

            except Exception as orchestration_error:
                logger.error(f"Error in document upload orchestration: {orchestration_error}")
                response_data['documents'] = 0
                response_data['message'] = f'Document upload orchestration failed: {str(orchestration_error)}'

            # Step 4b: Generate sample reports using the WORKING report pipeline
            if hasattr(g, 'api_key') and g.api_key:
                user_id = g.api_key.user_id
            else:
                auth_user = get_current_auth_user()
                user_id = auth_user['id']

            with get_db_session() as session:
                # Get available templates
                templates = session.query(ReportTemplate).filter(
                    ReportTemplate.is_active == True
                ).limit(3).all()

                if not templates:
                    response_data['message'] = 'No report templates available. Create templates first.'
                    response_data['reports'] = 0
                    return jsonify(response_data)

                reports_created = 0

                # Generate scenario-specific demo reports using the WORKING pipeline
                demo_report_configs = []

                if scenario in ['basic', 'comprehensive', 'healthcare']:
                    demo_report_configs.extend([
                        ("Demo: Healthcare Compliance Report", "Comprehensive HIPAA compliance analysis of medical records"),
                        ("Demo: PII Detection Summary", "Analysis of personally identifiable information across documents"),
                        ("Demo: Document Processing Report", "Summary of document ingestion and analysis results")
                    ])

                if scenario in ['comprehensive', 'security-focused']:
                    demo_report_configs.extend([
                        ("Demo: Security Audit Report", "Complete security assessment with findings and recommendations"),
                        ("Demo: Legal Document Analysis", "Analysis of legal documents for compliance and risk factors")
                    ])

                # Submit reports through the WORKING report service pipeline
                report_service = get_report_service()

                for i, (title, description) in enumerate(demo_report_configs):
                    template = templates[i % len(templates)]  # Cycle through available templates

                    # Create report request (starts as 'pending')
                    report = Report(
                        template_id=template.id,
                        user_id=user_id,
                        title=title,
                        description=description,
                        priority='normal',
                        parameters={'demo_scenario': scenario, 'demo_category': 'healthcare'},
                        output_format='pdf',
                        scrambling_enabled=True,
                        expires_at=datetime.utcnow() + timedelta(days=30)
                    )

                    session.add(report)
                    session.commit()

                    # Queue the report for processing (this is the WORKING pipeline)
                    queue_result = report_service.queue_report(report.id)

                    if queue_result.get('success'):
                        reports_created += 1
                        logger.info(f"Successfully queued demo report: {title}")
                    else:
                        logger.error(f"Failed to queue demo report {title}: {queue_result.get('error')}")

                response_data['reports'] = reports_created
                response_data['report_titles'] = [config[0] for config in demo_report_configs]
                response_data['message'] = f'Queued {reports_created} demo reports for generation via working pipeline'
                
        elif step == 5:
            # Step 5: Finalize setup
            response_data['message'] = f'Demo data generation completed for {scenario} scenario'
            
        return jsonify(response_data)
        
    except Exception as e:
        logger.error(f"Error generating demo data: {e}")
        return jsonify({
            'success': False,
            'error': str(e),
            'message': f'Failed to generate demo data at step {step}'
        }), 500

@admin_bp.route('/clear-demo-data', methods=['DELETE'])
@require_auth_or_api_key(['admin'])
def clear_demo_data():
    """Clear demo data from the system"""
    try:
        # Check admin permissions
        user_role = get_user_role()
        if user_role not in ['admin', 'super_admin']:
            return jsonify({'error': 'Admin access required'}), 403

        if hasattr(g, 'api_key') and g.api_key:
            user_id = g.api_key.user_id
        else:
            auth_user = get_current_auth_user()
            user_id = auth_user['id']
        
        with get_db_session() as session:
            # Delete demo reports (reports with "Demo" in title)
            demo_reports = session.query(Report).filter(
                Report.title.like('%Demo%')
            ).all()
            
            count_deleted = len(demo_reports)
            for report in demo_reports:
                session.delete(report)
            
            session.commit()
            
            logger.info(f"Cleared {count_deleted} demo reports")
            
            return jsonify({
                'success': True,
                'message': f'Cleared {count_deleted} demo reports',
                'reports_deleted': count_deleted
            })
            
    except Exception as e:
        logger.error(f"Error clearing demo data: {e}")
        return jsonify({
            'success': False,
            'error': str(e),
            'message': 'Failed to clear demo data'
        }), 500

@admin_bp.route('/system-status', methods=['GET'])
@require_auth_or_api_key(['admin'])
def get_system_status():
    """Get system status information for admin dashboard"""
    try:
        # Check admin permissions
        user_role = get_user_role()
        if user_role not in ['admin', 'super_admin']:
            return jsonify({'error': 'Admin access required'}), 403
        
        with get_db_session() as session:
            # Get system statistics
            total_reports = session.query(Report).count()
            completed_reports = session.query(Report).filter(
                Report.status == 'completed'
            ).count()
            pending_reports = session.query(Report).filter(
                Report.status.in_(['pending', 'queued', 'processing'])
            ).count()
            total_templates = session.query(ReportTemplate).filter(
                ReportTemplate.is_active == True
            ).count()
            total_users = session.query(User).count()
            
            # Get report service status
            report_service = get_report_service()
            queue_stats = report_service.get_queue_stats()
            service_healthy = report_service.health_check()
            
            return jsonify({
                'success': True,
                'data': {
                    'reports': {
                        'total': total_reports,
                        'completed': completed_reports,
                        'pending': pending_reports
                    },
                    'templates': {
                        'total': total_templates
                    },
                    'users': {
                        'total': total_users
                    },
                    'queue': queue_stats,
                    'service_health': service_healthy,
                    'timestamp': datetime.utcnow().isoformat()
                }
            })
            
    except Exception as e:
        logger.error(f"Error getting system status: {e}")
        return jsonify({
            'success': False,
            'error': str(e),
            'message': 'Failed to get system status'
        }), 500

@admin_bp.route('/pii-demo', methods=['GET'])
@require_auth_or_api_key(['admin'])
def get_pii_demo():
    """Get PII scrubbing demonstration with before/after comparison"""
    try:
        # Check admin permissions
        user_role = get_user_role()
        if user_role not in ['admin', 'super_admin']:
            return jsonify({'error': 'Admin access required'}), 403

        # Generate sample documents with PII for demonstration
        medical_gen = MedicalDemoGenerator()
        legal_gen = LegalDemoGenerator()
        financial_gen = FinancialDemoGenerator()

        # Create sample documents
        sample_docs = [
            {
                'id': 'medical_intake',
                'title': 'Patient Intake Form',
                'category': 'healthcare',
                'original': medical_gen.generate_patient_intake_form(),
                'description': 'Contains patient PHI including SSN, MRN, and contact information'
            },
            {
                'id': 'legal_case',
                'title': 'Legal Case File',
                'category': 'legal',
                'original': legal_gen.generate_case_file(),
                'description': 'Contains client information, SSNs, and financial data'
            },
            {
                'id': 'loan_app',
                'title': 'Loan Application',
                'category': 'financial',
                'original': financial_gen.generate_loan_application(),
                'description': 'Contains credit card numbers, bank accounts, and SSNs'
            }
        ]

        # For demo purposes, simulate PII scrubbing by creating anonymized versions
        scrubbed_docs = []
        pii_detections = []

        for doc in sample_docs:
            # Simulate PII detection and scrubbing
            original = doc['original']

            # Simple regex-based scrubbing for demo
            import re

            scrubbed = original
            detected_pii = []

            # SSN detection and scrubbing
            ssn_pattern = r'\b\d{3}-\d{2}-\d{4}\b'
            ssns = re.findall(ssn_pattern, original)
            for ssn in ssns:
                detected_pii.append({
                    'type': 'SSN',
                    'value': ssn,
                    'confidence': 0.98,
                    'location': original.find(ssn)
                })
                scrubbed = scrubbed.replace(ssn, 'XXX-XX-XXXX')

            # Phone number detection
            phone_pattern = r'\(\d{3}\) \d{3}-\d{4}'
            phones = re.findall(phone_pattern, original)
            for phone in phones:
                detected_pii.append({
                    'type': 'Phone',
                    'value': phone,
                    'confidence': 0.95,
                    'location': original.find(phone)
                })
                scrubbed = scrubbed.replace(phone, '(XXX) XXX-XXXX')

            # Email detection
            email_pattern = r'\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b'
            emails = re.findall(email_pattern, original)
            for email in emails:
                detected_pii.append({
                    'type': 'Email',
                    'value': email,
                    'confidence': 0.99,
                    'location': original.find(email)
                })
                scrubbed = scrubbed.replace(email, 'XXXXXXX@domain.com')

            # Medical Record Numbers
            mrn_pattern = r'MRN\d{6}'
            mrns = re.findall(mrn_pattern, original)
            for mrn in mrns:
                detected_pii.append({
                    'type': 'Medical Record Number',
                    'value': mrn,
                    'confidence': 0.97,
                    'location': original.find(mrn)
                })
                scrubbed = scrubbed.replace(mrn, 'MRNXXXXXX')

            # Credit Card Numbers (basic detection)
            cc_pattern = r'\b\d{4}-\d{4}-\d{4}-\d{4}\b'
            cards = re.findall(cc_pattern, original)
            for card in cards:
                detected_pii.append({
                    'type': 'Credit Card',
                    'value': card,
                    'confidence': 0.96,
                    'location': original.find(card)
                })
                scrubbed = scrubbed.replace(card, 'XXXX-XXXX-XXXX-XXXX')

            scrubbed_docs.append({
                'id': doc['id'],
                'title': doc['title'],
                'category': doc['category'],
                'description': doc['description'],
                'original': original,
                'scrubbed': scrubbed,
                'pii_detected': detected_pii,
                'scrubbing_stats': {
                    'total_pii_instances': len(detected_pii),
                    'pii_types': list(set([p['type'] for p in detected_pii])),
                    'scrubbing_effectiveness': 100.0,  # Demo shows perfect scrubbing
                    'processing_time_ms': 1200 + len(original) // 10  # Simulated processing time
                }
            })

        return jsonify({
            'success': True,
            'demo_documents': scrubbed_docs,
            'summary': {
                'total_documents': len(scrubbed_docs),
                'total_pii_detected': sum(len(doc['pii_detected']) for doc in scrubbed_docs),
                'categories_analyzed': list(set(doc['category'] for doc in scrubbed_docs)),
                'demo_generated_at': datetime.utcnow().isoformat()
            }
        })

    except Exception as e:
        logger.error(f"Error generating PII demo: {e}")
        return jsonify({
            'success': False,
            'error': str(e),
            'message': 'Failed to generate PII demonstration'
        }), 500